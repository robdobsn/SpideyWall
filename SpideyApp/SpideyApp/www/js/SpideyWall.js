// Generated by CoffeeScript 1.8.0
var SpideyWall,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

SpideyWall = (function() {
  function SpideyWall() {
    this.spideyGeometry = window.SpideyGeometry;
    this.pointsInGeometry = this.generatePointInfo();
    this.wrapAroundNodeIdxs = null;
    this.wrapAroundNodes = {
      79: 73,
      73: 79,
      77: 75,
      75: 77,
      61: 69,
      69: 61,
      60: 68,
      68: 60,
      76: 78,
      78: 76,
      74: 62,
      62: 74,
      65: 63,
      63: 65,
      64: 72,
      72: 64,
      71: 63,
      66: 72,
      67: 72,
      70: 60
    };
  }

  SpideyWall.prototype.getLinks = function() {
    return this.spideyGeometry.links;
  };

  SpideyWall.prototype.getPoints = function() {
    return this.pointsInGeometry;
  };

  SpideyWall.prototype.getNumPoints = function() {
    return this.pointsInGeometry.length;
  };

  SpideyWall.prototype.getWrapNodeIdx = function(nodeIdx) {
    if (nodeIdx in this.wrapAroundNodes) {
      return this.wrapAroundNodes[nodeIdx];
    }
    return this.getRandomEdgeNodeIdx(nodeIdx);
  };

  SpideyWall.prototype.getRandomEdgeNodeIdx = function(nodeIdx) {
    var nod, nodIdx, randElem, _i, _len, _ref;
    if (this.wrapAroundNodeIdxs == null) {
      this.wrapAroundNodeIdxs = [];
      _ref = this.spideyGeometry.nodes;
      for (nodIdx = _i = 0, _len = _ref.length; _i < _len; nodIdx = ++_i) {
        nod = _ref[nodIdx];
        if (nod.linkIdxs.length === 1) {
          this.wrapAroundNodeIdxs.push(nodIdx);
        }
      }
    }
    randElem = Math.floor(Math.random() * this.wrapAroundNodeIdxs.length);
    if (randElem < this.wrapAroundNodeIdxs.length) {
      return this.wrapAroundNodeIdxs[randElem];
    }
    return nodeIdx;
  };

  SpideyWall.prototype.getStepDist = function() {
    return 7;
  };

  SpideyWall.prototype.getNumNodes = function() {
    return this.spideyGeometry.nodes.length;
  };

  SpideyWall.prototype.getNodeXY = function(nodeIdx) {
    var node;
    node = this.spideyGeometry.nodes[nodeIdx];
    return {
      x: node.x,
      y: node.y
    };
  };

  SpideyWall.prototype.getLinkAngle = function(nodeIdx, nodeLinkIdx, moveDirection) {
    var link, linkIdx, node;
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    if (link == null) {
      debugger;
    }
    if (moveDirection > 0) {
      return link.linkAngle;
    }
    if (link.linkAngle > 0) {
      return link.linkAngle - 180;
    } else {
      return link.linkAngle + 180;
    }
  };

  SpideyWall.prototype.getLinkLedXY = function(nodeIdx, nodeLinkIdx, linkStep) {
    var led, ledIdx, link, linkIdx, node;
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    ledIdx = link.padEdges[0].ledIdxs[linkStep];
    led = this.spideyGeometry.leds[ledIdx];
    if (led == null) {
      console.log("Error no led");
    }
    return {
      x: led.x,
      y: led.y
    };
  };

  SpideyWall.prototype.getNumLinks = function(nodeIdx) {
    var node;
    node = this.spideyGeometry.nodes[nodeIdx];
    return node.linkIdxs.length;
  };

  SpideyWall.prototype.getLinkLength = function(nodeIdx, nodeLinkIdx) {
    var edgeLen, link, linkIdx, node, padEdge, _i, _len, _ref;
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    edgeLen = 1000;
    _ref = link.padEdges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      padEdge = _ref[_i];
      if (edgeLen > padEdge.ledIdxs.length) {
        edgeLen = padEdge.ledIdxs.length;
      }
    }
    return edgeLen;
  };

  SpideyWall.prototype.getLinkTarget = function(nodeIdx, nodeLinkIdx) {
    var link, linkIdx, node;
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    if ((link == null) || (link.target == null)) {
      debugger;
    }
    return link.target;
  };

  SpideyWall.prototype.getLinkCofG = function(nodeIdx, nodeLinkIdx, linkStep) {
    var cnt, edge, led, ledIdx, link, linkIdx, node, xCofG, yCofG, _i, _len, _ref;
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    xCofG = 0;
    yCofG = 0;
    cnt = 0;
    _ref = link.padEdges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (linkStep < edge.ledIdxs.length) {
        ledIdx = edge.ledIdxs[linkStep];
        led = this.spideyGeometry.leds[ledIdx];
        xCofG += led.x;
        yCofG += led.y;
        cnt++;
      }
    }
    if (cnt === 0) {
      cnt = 2;
      xCofG = link.xSource + link.xTarget;
      yCofG = link.ySource + link.yTarget;
    }
    return {
      x: xCofG / cnt,
      y: yCofG / cnt
    };
  };

  SpideyWall.prototype.getNodeNearXY = function(x, y) {
    var bestDist, bestIdx, dist, nod, nodIdx, nodXy, _i, _len, _ref;
    bestDist = 1000000;
    bestIdx = -1;
    _ref = this.spideyGeometry.nodes;
    for (nodIdx = _i = 0, _len = _ref.length; _i < _len; nodIdx = ++_i) {
      nod = _ref[nodIdx];
      nodXy = this.getNodeXY(nodIdx);
      dist = Math.pow(x - nodXy.x, 2) + Math.pow(y - nodXy.y, 2);
      if (bestDist > dist) {
        bestDist = dist;
        bestIdx = nodIdx;
      }
    }
    return bestIdx;
  };

  SpideyWall.prototype.getPositionXY = function(nodeIdx, nodeLinkIdx, linkStep) {
    var xyPos;
    xyPos = null;
    if (nodeLinkIdx < 0) {
      xyPos = this.getNodeXY(nodeIdx);
    } else {
      xyPos = this.getLinkCofG(nodeIdx, nodeLinkIdx, linkStep);
    }
    if (xyPos == null) {
      debugger;
    }
    return xyPos;
  };

  SpideyWall.prototype.getPositionPointIdx = function(nodeIdx, nodeLinkIdx, linkStep) {
    var link, linkIdx, node;
    if (nodeLinkIdx < 0) {
      if (this.spideyGeometry.nodes[nodeIdx].pointIdx == null) {
        debugger;
      }
      return this.spideyGeometry.nodes[nodeIdx].pointIdx;
    }
    node = this.spideyGeometry.nodes[nodeIdx];
    linkIdx = node.linkIdxs[nodeLinkIdx];
    link = this.spideyGeometry.links[linkIdx];
    if (link.pointIdxs[linkStep] == null) {
      return node.pointIdx;
    }
    return link.pointIdxs[linkStep];
  };

  SpideyWall.prototype.generatePointInfo = function() {
    var link, linkIdx, linkLen, linkPoints, linksIdxsProcessed, nod, nodIdx, nodeLinkIdx, pointInf, pointList, revLinkPoints, revLnk, revLnkTest, stepIdx, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
    linksIdxsProcessed = [];
    pointList = [];
    _ref = this.spideyGeometry.nodes;
    for (nodIdx = _i = 0, _len = _ref.length; _i < _len; nodIdx = ++_i) {
      nod = _ref[nodIdx];
      nod.pointIdx = pointList.length;
      pointList.push({
        x: nod.x,
        y: nod.y,
        nodeIdx: nodIdx,
        linkIdx: -1,
        linkStep: 0
      });
      for (nodeLinkIdx = _j = 0, _ref1 = nod.linkIdxs.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; nodeLinkIdx = 0 <= _ref1 ? ++_j : --_j) {
        linkIdx = nod.linkIdxs[nodeLinkIdx];
        if (__indexOf.call(linksIdxsProcessed, linkIdx) < 0) {
          linksIdxsProcessed.push(linkIdx);
          link = this.spideyGeometry.links[linkIdx];
          linkLen = this.getLinkLength(nodIdx, nodeLinkIdx);
          linkPoints = [];
          for (stepIdx = _k = 0; 0 <= linkLen ? _k < linkLen : _k > linkLen; stepIdx = 0 <= linkLen ? ++_k : --_k) {
            linkPoints.push(pointList.length);
            pointInf = this.getLinkCofG(nodIdx, nodeLinkIdx, stepIdx);
            pointInf.nodeIdx = nodIdx;
            pointInf.linkIdx = nodeLinkIdx;
            pointInf.linkStep = stepIdx;
            pointList.push(pointInf);
          }
          link.pointIdxs = linkPoints;
          revLnk = null;
          _ref2 = this.spideyGeometry.links;
          for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {
            revLnkTest = _ref2[_l];
            if (revLnkTest.source === link.target && revLnkTest.target === link.source) {
              linksIdxsProcessed.push(revLnkTest.linkIdx);
              revLnk = revLnkTest;
              revLinkPoints = linkPoints.slice(0);
              revLinkPoints.reverse();
              revLnk.pointIdxs = revLinkPoints;
              break;
            }
          }
        }
      }
    }
    return pointList;
  };

  SpideyWall.prototype.getPointNearXY = function(x, y) {
    var bestDist, bestIdx, dist, pt, ptIdx, _i, _len, _ref;
    bestDist = 1000000;
    bestIdx = -1;
    _ref = this.pointsInGeometry;
    for (ptIdx = _i = 0, _len = _ref.length; _i < _len; ptIdx = ++_i) {
      pt = _ref[ptIdx];
      dist = Math.pow(x - pt.x, 2) + Math.pow(y - pt.y, 2);
      if (bestDist > dist) {
        bestDist = dist;
        bestIdx = ptIdx;
      }
    }
    return bestIdx;
  };

  SpideyWall.prototype.dist = function(pt1, pt2) {
    return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));
  };

  return SpideyWall;

})();
